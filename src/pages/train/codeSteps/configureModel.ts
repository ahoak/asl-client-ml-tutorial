import * as tf from '@tensorflow/tfjs';

import type { ValidationResult } from '../../../types';
import { ValidationErrorType } from '../../../types';
import { createIncompleteImplValidationError } from '../../../utils/utils';

export const template = `
// https://js.tensorflow.org/api/latest/#tf.LayersModel.compile
/**
 * @param {tf.LayersModel} model The model to run the compile with

 */
function configureModel(model: LayersModel):LayersModel {
  // Configures and prepares the model for training and evaluation. Compiling outfits the model with an optimizer, loss, and/or metrics
  
  // Optimizer: The job of the optimizer is to decide how much to change each parameter in the model, given the current model prediction.
  // Loss Function: Its goal is to give a single number for "how wrong" the model's prediction was. The loss is computed on every batch of data so that the model can update its weights.
  // List of Metrics: Similar to losses, metrics compute a single number, summarizing how well our model is doing. The metrics are usually computed on the whole data at the end of each epoch
 
  model.compile({
    // Adam changes the learning rate over time which is useful.
    // https://js.tensorflow.org/api/latest/#Training-Optimizers
    optimizer:  /*<input>*/, //optimizer options: tf.train.sgd, tf.train.momentum, tf.train.adagrad, tf.train.ada, tf.train.adam, tf.train.adamax, tf.train.rmsprop

    // Use the correct loss function. https://js.tensorflow.org/api/latest/#Training-Losses
    // If 2 classes of data, use binaryCrossentropy else use categoricalCrossentropy is used if more than 2 classes and output of our model is a probability distribution.
    // This measures the error between the probability distribution generated by the last layer of our model and the probability distribution given by our true label
    loss:  /*<input>*/,
    // As this is a classification problem you can record accuracy in the logs too!
    metrics: ['accuracy'],
  });
    return model
  }
  `;

export const solution = `
  // https://js.tensorflow.org/api/latest/#tf.LayersModel.compile
  /**
   * @param {tf.LayersModel} model The model to run the compile with
  
   */
  function configureModelSolution(model: LayersModel):LayersModel {
      model.compile({
        optimizer: tf.train.adam(0.001),
        loss: 'categoricalCrossentropy',
        metrics: ['accuracy'],
      });
      return model
  }
    `;

// eslint-disable-next-line @typescript-eslint/ban-types
export function implementation<T = (...args: any[]) => any>(
  code: string,
  layerModel: LayersModel,
): T {
  // eslint-disable-next-line @typescript-eslint/no-implied-eval, no-new-func
  const wrapper = new Function('model', 'tf', 'tfjs', `return (${code.replace(/export/g, '')})`);
  return wrapper(layerModel, tf, tf) as T;
}

type configureModel = (model: LayersModel) => LayersModel;

export async function validate(
  impl: configureModel,
  model: LayersModel,
): Promise<ValidationResult> {
  let result = model;
  try {
    // eslint-disable-next-line @typescript-eslint/await-thenable
    result = await impl(model);
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const output = model.evaluate(tf.truncatedNormal([1, 63]), tf.truncatedNormal([1, 26]));
    if (!output) {
      return createIncompleteImplValidationError(`
      The model does not seemed to be compiled or compiled correctly'
      `);
    }
  } catch (e) {
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    const error = `${e}`;
    return {
      valid: false,
      errors: [
        {
          type: ValidationErrorType.Unknown,
          detail: error,
        },
      ],
    };
  }

  return {
    valid: true,
    errors: [],
    data: [result],
  };
}
